Date Tested: 20/08/2025
Date of CVE: 7 April 2014 ([reference](https://openssl-library.org/news/vulnerabilities-1.0.1/))
Category: Buffer over-read

---  
## Summary  
The Heartbeat extension used in HTTPs provided a way to keep-alive TLS communication links without the need to renegotiate the connection each time.

The Heartbleed bug is the result of improper input validation due to a missing bounds check in the heartbeat extension; it did not sanity check what the server was given before responding, specifically not checking the heartbeat response was bigger than the request.

The fix to prevent the memory leak from occurring was to ensure the response size matched the request size, otherwise ignore the packet.

---  
## Exploit Details  

**Type of Exploit:** Buffer over-read
**Tools Used:** searchsploit, nmap
  
### Steps taken
1. a docker container was setup with the heartbleed vulnerability on port 1003
2. `searchsploit heartbleed`
3. `searchsploit -m {path}` to mirror/copy to current working directory
4. `mv 32765.py heartbleed.py`
5. `python heartbleed.py -h`
6. ping target to ensure it is reachable
7. nmap -p 1003 target.ip to ensure the port is open
8. python2 heartbleed.py 10.220.0.31 -p 1003
![[Pasted image 20250820143328.png]]
  
---  
## Impact  
This allowed attackers to buffer over-read arbitrary memory of vulnerable systems, which could lead to the compromise of secret keys, session IDs, names, passwords and other sensitive information. The private key could be used to decrypt all of the SSL communications with the web server as well as impersonate the web server.

- Affected OpenSSL v1.0.1 and before v1.0.1g ([CVE Record](https://www.cve.org/CVERecord?id=CVE-2014-0160))
---
## Technical Breakdown  
In normal operation, the TLS encryption channel used for HTTPs had clients send heartbeat requests to see if the connection was active, then the server would respond if the line was still open. This allowed to keep-alive secure communication links without the need to re-negotiate the connection e.g. while a user is on a website.

An attacker could modify heartbeat requests to exploit it.

Note: A TLS maximum record size minus overhead is 2^14-3 = 16,381 bytes in total.

Exploitation breakdown:
1. User sends heartbeat request asking for 'Hey' + 400 bytes
2. Even though the actual payload is 3 bytes, the server copies and responds with Hey and 397 bytes from it's memory
3. Attacker repeatedly sends packets to continuously retrieve data from the server's memory
   
Root cause was in the Heartbeat response code:
**![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXe3a3qnckz4zZiU99gZH-kx4lQqvk1Or5sVJmc-v4UBEU7NM19ueOOUkowu632_91AEm3RWzFOxMKK4qGpOuE058YKNqo8ZXR7R-zuEi504HVpCILIg4f1BS0ilWUl5tBeCxrtrBnrq5Hqba_NCz0K0HYo?key=J_rADSLql1n-Vl_QRb_ubnx1)**
**![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcMMH4_D_xoUJS9gJvhQzcolyJ7OxSkkqKjPw1gAEmrIEO4eQa_WXUSwk_NzLJRgmX4UhunAjaBzc0LE0XUQ0ze31HD9P6HCyOp7vfrg8orA9kkYAydVpJEOpjEd9sJAL1fvmjdBYvFoE0KmLjpLKEV4AU?key=J_rADSLql1n-Vl_QRb_ubnx1)**
The following line of C code caused the vulnerability:
   `memcpy(bp, pl, payload)`
   
   payload = claimed length of the payload (sent by the client)
   pl: pointer to the payload data sent by the client
   bp: buffer pointer where the response is being constructed
   
Essentially, it blindly copies `payload` from `pl` to `bp`.  The `payload` is supplied by the client and there is no verification check to validate the payload equaled the length of the original content.
  
---  
## The Fix  
The implemented fix from OpenSSL added the following code (bounds check):
```
If (1 + 2 + payload + 16 > s ->s3->rrec.length)
return 0;
```
This adds the sum of all elements in the heartbeat response and checks it's not longer than the length of the client-sent heartbeat request.
- s->s3->rrec.length = the actual record length as received by OpenSSL.
The check guarantees that the claimed heartbeat message structure (type + length + payload + padding) does not exceed the **actual record length** received.

Post-fix example:
1. attacker sends 'HAT' + 400 bytes
2. Server checks if 1 + 2 + 400 + 16 > the heartbeat request actual TLS record length
- e.g. 01 01 90 "ABC" = 1 byte + 2 byte + 3 byte = 6 bytes total = Actual TLS record length
	- Payload length field (01 90) = 400 bytes
	- Since 419 > 6 bytes, the Server returns zero (does nothing)

Heartbeat request message structure:
![[Pasted image 20250820140715.png]]
Heartbeat response message structure:
![[Pasted image 20250820140552.png]]

---  
### Mitigation  
Affected users should upgrade to OpenSSL 1.0.1g. Users unable to immediately
upgrade can alternatively recompile OpenSSL with -DOPENSSL_NO_HEARTBEATS.
  
---  
## References & Reports  
- [CVE Record](https://www.cve.org/CVERecord?id=CVE-2014-0160), [OpenSSL Library](https://openssl-library.org/news/vulnerabilities-1.0.1/), [OpenSSL Advisory](https://openssl-library.org/news/secadv/20140407.txt)
- [Heartbleed lab docker image](https://github.com/jas9reet/heartbleed-lab)
---